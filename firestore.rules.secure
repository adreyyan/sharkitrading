rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper functions for validation
    function isValidEthereumAddress(address) {
      return address is string && 
             address.size() == 42 && 
             address[0:2] == '0x' &&
             address.matches('^0x[a-fA-F0-9]{40}$');
    }
    
    function isValidTradeStatus(status) {
      return status in ['pending', 'accepted', 'declined', 'cancelled'];
    }
    
    function isValidNFTItem(item) {
      return item.keys().hasAll(['contract', 'tokenId']) &&
             isValidEthereumAddress(item.contract) &&
             item.tokenId is string &&
             item.tokenId.size() > 0;
    }
    
    function isValidNFTArray(nfts) {
      return nfts is list &&
             nfts.size() <= 50 && // Reasonable limit
             nfts.all(item => isValidNFTItem(item));
    }
    
    function isValidMonadAmount(amount) {
      return amount is string &&
             amount.matches('^[0-9]+(\\.[0-9]+)?$') &&
             float(amount) >= 0 &&
             float(amount) <= 1000000; // Reasonable upper limit
    }
    
    // User authentication helper (for future implementation)
    function isAuthenticated() {
      return request.auth != null && request.auth.uid != null;
    }
    
    function getUserWalletAddress() {
      // This assumes wallet address is stored in custom claims or user document
      // You would implement this based on your authentication strategy
      return request.auth.token.wallet_address;
    }
    
    // Trades collection rules - SECURE VERSION
    match /trades/{tradeId} {
      // Allow read only if user is involved in the trade
      allow read: if resource != null &&
                     isAuthenticated() &&
                     (resource.data.from == getUserWalletAddress() ||
                      resource.data.to == getUserWalletAddress());
      
      // Allow public read for specific trade IDs (for sharing)
      // You might want to implement a separate sharing mechanism
      allow get: if resource != null;
      
      // Allow create for authenticated users with valid data
      allow create: if 
        isAuthenticated() &&
        
        // Validate required fields exist
        request.resource.data.keys().hasAll(['from', 'to', 'offer', 'requested', 'status', 'createdAt']) &&
        
        // Ensure creator matches authenticated user's wallet
        request.resource.data.from == getUserWalletAddress() &&
        
        // Validate addresses
        isValidEthereumAddress(request.resource.data.from) &&
        isValidEthereumAddress(request.resource.data.to) &&
        request.resource.data.from != request.resource.data.to &&
        
        // Validate NFT arrays
        isValidNFTArray(request.resource.data.offer) &&
        isValidNFTArray(request.resource.data.requested) &&
        
        // Validate MONAD amounts (optional fields)
        (!('offeredMonad' in request.resource.data) || isValidMonadAmount(request.resource.data.offeredMonad)) &&
        (!('requestedMonad' in request.resource.data) || isValidMonadAmount(request.resource.data.requestedMonad)) &&
        
        // Validate status
        isValidTradeStatus(request.resource.data.status) &&
        request.resource.data.status == 'pending' && // New trades must start as pending
        
        // Validate timestamps
        request.resource.data.createdAt == request.time &&
        (!('expiresAt' in request.resource.data) || request.resource.data.expiresAt is timestamp) &&
        
        // Validate optional fields
        (!('message' in request.resource.data) || 
         (request.resource.data.message is string && request.resource.data.message.size() <= 500)) &&
        (!('blockchainTradeId' in request.resource.data) || 
         (request.resource.data.blockchainTradeId is string && request.resource.data.blockchainTradeId.size() <= 100)) &&
        
        // Ensure at least one side has something to trade
        (request.resource.data.offer.size() > 0 || 
         ('offeredMonad' in request.resource.data && float(request.resource.data.offeredMonad) > 0)) &&
        (request.resource.data.requested.size() > 0 || 
         ('requestedMonad' in request.resource.data && float(request.resource.data.requestedMonad) > 0));
      
      // Allow update only for status changes by involved parties
      allow update: if 
        isAuthenticated() &&
        resource != null &&
        
        // Only allow status updates and addition of updatedAt timestamp
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'updatedAt']) &&
        
        // Validate new status
        isValidTradeStatus(request.resource.data.status) &&
        
        // Validate updatedAt timestamp
        request.resource.data.updatedAt == request.time &&
        
        // Permission logic based on who is making the update
        (
          // Creator can cancel pending trades
          (resource.data.from == getUserWalletAddress() &&
           resource.data.status == 'pending' &&
           request.resource.data.status == 'cancelled') ||
          
          // Counterparty can accept or decline pending trades
          (resource.data.to == getUserWalletAddress() &&
           resource.data.status == 'pending' &&
           request.resource.data.status in ['accepted', 'declined'])
        );
      
      // Deny delete operations - trades should be permanent records
      allow delete: if false;
    }
    
    // Query rules for trades collection - SECURE VERSION
    match /trades {
      // Allow querying only trades where authenticated user is involved
      allow list: if 
        isAuthenticated() &&
        request.query.limit <= 100; // Reasonable pagination limit
        // Note: Additional query constraints should be added in your application code
        // to filter by 'from' or 'to' fields matching the user's wallet address
    }
    
    // Future: User profiles collection (when implementing user accounts)
    match /users/{userId} {
      allow read, write: if isAuthenticated() && request.auth.uid == userId;
    }
    
    // Deny access to any other collections
    match /{document=**} {
      allow read, write: if false;
    }
  }
} 